version: 2.1

parameters:
  gen_changelog_version:
    type: string
    default: ""
    description: "Version override for gen-changelog crate (empty = auto-detect)"

orbs:
  toolkit: jerus-org/circleci-toolkit@4.4.3

# Commands designed for future migration to circleci-toolkit
# These extend existing toolkit patterns with backward-compatible parameters
commands:
  # Enhanced version of toolkit/get_next_version with prefix and subdir support
  # Backward compatible: existing behavior when prefix/subdir not provided
  get_next_version:
    description: >
      Calculate the next version number and save it to the NEXT_VERSION environment variable.
      Enhanced version that supports --prefix and --subdir for crate-specific version detection.
      When prefix/subdir are empty, behaves identically to toolkit/get_next_version.
    parameters:
      version:
        type: string
        default: ""
        description: "Specific version number to release (overrides calculation)"
      package:
        type: string
        default: ""
        description: "Package to release and/or publish"
      prefix:
        type: string
        default: ""
        description: "Tag prefix for version detection (e.g., gen-changelog-v)"
      subdir:
        type: string
        default: ""
        description: "Subdirectory containing the crate (for monorepo support)"
      verbosity:
        type: string
        default: "-q"
        description: "Verbosity flag for nextsv command"
    steps:
      - run:
          name: Calculate next version
          command: |
            set -eo pipefail

            # If specific version provided, use it directly
            if [ "<< parameters.version >>" != "" ]; then
              version="<< parameters.version >>"
              echo "Using specified version: $version"
              echo "export NEXT_VERSION=$version" >> "$BASH_ENV"
              echo "export SEMVER=$version" >> "$BASH_ENV"
              exit 0
            fi

            # Build nextsv arguments
            nextsv_args="<< parameters.verbosity >> -bn calculate"

            if [ "<< parameters.package >>" != "" ]; then
              nextsv_args="$nextsv_args --package << parameters.package >>"
            fi

            if [ "<< parameters.prefix >>" != "" ]; then
              nextsv_args="$nextsv_args --prefix << parameters.prefix >>"
            fi

            if [ "<< parameters.subdir >>" != "" ]; then
              nextsv_args="$nextsv_args --subdir << parameters.subdir >>"
            fi

            # Calculate version
            version=$(nextsv $nextsv_args 2>/dev/null || echo "")

            if [ -z "$version" ]; then
              echo "No release needed"
              version="none"
            else
              echo "Next version: $version"
            fi

            # Set both NEXT_VERSION (toolkit standard) and SEMVER (for make_cargo_release)
            echo "export NEXT_VERSION=$version" >> "$BASH_ENV"
            echo "export SEMVER=$version" >> "$BASH_ENV"

  # New command: Check if version exists on crates.io
  # Used for recovery scenarios where publish succeeded but workflow failed
  check_crates_io_version:
    description: >
      Check if a version already exists on crates.io.
      Sets SKIP_PUBLISH=true if version exists, false otherwise.
      Used for recovery scenarios where crates.io publish succeeded but workflow failed afterward.
    parameters:
      package:
        type: string
        description: "Crate name on crates.io"
    steps:
      - run:
          name: Check crates.io for << parameters.package >>
          command: |
            set -eo pipefail

            # Use SEMVER or NEXT_VERSION (whichever is set)
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ]; then
              echo "No version to check"
              echo "export SKIP_PUBLISH=false" >> "$BASH_ENV"
              exit 0
            fi

            USER_AGENT="circleci-toolkit/1.0 (https://github.com/jerus-org/circleci-toolkit)"

            if curl -s -H "User-Agent: ${USER_AGENT}" "https://crates.io/api/v1/crates/<< parameters.package >>/versions" | \
               jq -e ".versions[] | select(.num == \"${VERSION}\")" > /dev/null 2>&1; then
              echo "Version ${VERSION} exists on crates.io - will skip publish"
              echo "export SKIP_PUBLISH=true" >> "$BASH_ENV"
            else
              echo "Version ${VERSION} not found on crates.io - will publish"
              echo "export SKIP_PUBLISH=false" >> "$BASH_ENV"
            fi

  # New command: Check if release tag already exists
  # Used for recovery scenarios where tag was created but workflow failed
  check_tag_exists:
    description: >
      Check if the release tag already exists.
      Sets SKIP_RELEASE=true if tag exists, false otherwise.
      Used for recovery scenarios where release partially succeeded.
    parameters:
      package:
        type: string
        description: "Package name (used to construct tag name)"
    steps:
      - run:
          name: Check if tag exists for << parameters.package >>
          command: |
            set -eo pipefail

            # Use SEMVER or NEXT_VERSION (whichever is set)
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ]; then
              echo "No version to check"
              echo "export SKIP_RELEASE=false" >> "$BASH_ENV"
              exit 0
            fi

            TAG="<< parameters.package >>-v${VERSION}"

            # Fetch tags from remote
            git fetch --tags

            if git tag -l "$TAG" | grep -q .; then
              echo "Tag ${TAG} already exists - will skip release"
              echo "export SKIP_RELEASE=true" >> "$BASH_ENV"
            else
              echo "Tag ${TAG} not found - will proceed with release"
              echo "export SKIP_RELEASE=false" >> "$BASH_ENV"
            fi

  # Enhanced make_cargo_release with conditional publish support
  # Backward compatible: publishes by default unless SKIP_PUBLISH=true or publish=false
  # Also respects SKIP_RELEASE=true to skip entirely when tag already exists
  make_cargo_release:
    description: >
      Make a release using cargo release.
      Enhanced version that respects SKIP_PUBLISH environment variable for recovery scenarios.
      When SKIP_PUBLISH=true, adds --no-publish flag to skip crates.io publish.
      The publish parameter controls default behavior; SKIP_PUBLISH overrides it at runtime.
    parameters:
      package:
        type: string
        default: ""
        description: "Package to release"
      verbosity:
        type: string
        default: "-vv"
        description: "Verbosity for cargo release"
      publish:
        type: boolean
        default: true
        description: "If true, the release will be published to crates.io"
      no_push:
        type: boolean
        default: false
        description: "Whether cargo release should push the changes"
    steps:
      - run:
          name: List changes using cargo release
          command: |
            set -exo pipefail
            cargo release changes
      - run:
          name: Execute cargo release
          command: |
            set -exo pipefail

            # Check if release should be skipped (tag already exists)
            if [ "$SKIP_RELEASE" = "true" ]; then
              echo "Skipping release (tag already exists)"
              exit 0
            fi

            # Use SEMVER or NEXT_VERSION
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ]; then
              echo "No version to release - skipping"
              exit 0
            fi

            echo "Releasing version: $VERSION"

            # Build cargo release arguments
            release_args="--execute --no-confirm --sign-tag"

            if [ "<< parameters.package >>" != "" ]; then
              release_args="$release_args --package << parameters.package >>"
            fi

            if [ "<< parameters.no_push >>" = "true" ]; then
              release_args="$release_args --no-push"
            fi

            # Handle publish: parameter controls default, SKIP_PUBLISH overrides at runtime
            if [ "<< parameters.publish >>" = "false" ]; then
              release_args="$release_args --no-publish"
              echo "Publishing disabled by parameter"
            elif [ "$SKIP_PUBLISH" = "true" ]; then
              release_args="$release_args --no-publish"
              echo "Skipping publish (version already on crates.io)"
            fi

            # Map verbosity
            case "<< parameters.verbosity >>" in
              "-vvv"|"-vvvv")
                release_args="-vv $release_args"
                ;;
            esac

            cargo release $release_args "$VERSION"

  # Enhanced make_github_release with package support
  make_github_release:
    description: >
      Create a GitHub release using the pcu utility.
      When package is provided, uses 'pcu release package' which derives the correct tag prefix.
      When package is empty, uses 'pcu release version' with the specified prefix.
    parameters:
      prefix:
        type: string
        default: "v"
        description: "Tag prefix for the release (used when package is empty)"
      package:
        type: string
        default: ""
        description: "Package name - when provided, derives tag prefix automatically"
      verbosity:
        type: string
        default: "-vv"
        description: "Verbosity for pcu command"
      update_prlog:
        type: boolean
        default: false
        description: "Update PRLOG when creating the release"
    steps:
      - run:
          name: Create GitHub release
          command: |
            set -exo pipefail

            # Use SEMVER or NEXT_VERSION
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ]; then
              echo "No version to release - skipping GitHub release"
              exit 0
            fi

            # Determine the tag name
            if [ "<< parameters.package >>" != "" ]; then
              TAG="<< parameters.package >>-v${VERSION}"
            else
              TAG="<< parameters.prefix >>${VERSION}"
            fi

            # Check if GitHub release already exists using API
            # Extract owner/repo from git remote
            REPO_URL=$(git remote get-url origin)
            REPO_PATH=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]||' | sed 's|\.git$||')

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${REPO_PATH}/releases/tags/${TAG}")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "GitHub release ${TAG} already exists - skipping"
              exit 0
            fi
            echo "GitHub release ${TAG} not found (HTTP ${HTTP_STATUS}) - will create"

            # --update-prlog and --prefix are release-level flags (before the subcommand)
            release_opts=""
            if [ "<< parameters.update_prlog >>" = "true" ]; then
              release_opts="$release_opts --update-prlog"
            fi

            if [ "<< parameters.package >>" != "" ]; then
              pcu << parameters.verbosity >> release $release_opts package << parameters.package >>
            else
              pcu << parameters.verbosity >> release $release_opts --prefix << parameters.prefix >> version "$VERSION"
            fi

  # Build a release binary using cargo.
  # Requires VERSION environment variable (skips if "none").
  build_release_binary:
    description: >
      Build a release-optimised binary using cargo build --release.
      Expects VERSION to be set in BASH_ENV; skips when VERSION is "none".
      Also skips when SKIP_PUBLISH=true (ephemeral signing key unavailable)
      or SKIP_RELEASE=true (key from the original release session is gone).
    steps:
      - run:
          name: Build release binary
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ]; then
              echo "No version to release - skipping"
              exit 0
            fi

            # Skip binary when the release commit is already on remote.
            # SKIP_RELEASE=true means the original ephemeral key session is gone.
            if [ "$SKIP_RELEASE" = "true" ]; then
              echo "Skipping binary build: tag already on remote, ephemeral key unavailable"
              exit 0
            fi

            cargo build --release

  # Package a binary from target/release into a .tar.gz archive.
  # Sets ASSET_NAME in BASH_ENV for use by upload_release_asset.
  package_binary:
    description: >
      Package a binary from target/release into a .tar.gz archive named
      <binary_name>-<target>.tar.gz. Sets ASSET_NAME in BASH_ENV.
    parameters:
      binary_name:
        type: string
        description: "Name of the binary in target/release"
      target:
        type: string
        default: x86_64-unknown-linux-gnu
        description: "Rust target triple for the archive name"
    steps:
      - run:
          name: Package binary as tar.gz
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "No version to release or binary skipped - skipping"
              exit 0
            fi

            ASSET_NAME="<< parameters.binary_name >>-<< parameters.target >>.tar.gz"

            tar czf "$ASSET_NAME" -C target/release "<< parameters.binary_name >>"
            echo "Created $ASSET_NAME ($(du -h "$ASSET_NAME" | cut -f1))"

            echo "export ASSET_NAME=$ASSET_NAME" >> "$BASH_ENV"

  # Upload a binary asset to a GitHub release.
  # Adapted from toolkit/upload_release_asset with release_tag parameter
  # so it works in pipelines where CIRCLE_TAG is not set.
  upload_release_asset:
    description: >
      Upload a binary asset to a GitHub release. Accepts a release_tag
      parameter instead of relying on CIRCLE_TAG, making it usable in
      scheduled/manual pipelines. Requires GITHUB_TOKEN environment variable.
    parameters:
      asset_path:
        type: string
        description: "Path to the asset file to upload"
      asset_name:
        type: string
        default: ""
        description: "Name for the asset in the release (defaults to filename)"
      release_tag:
        type: string
        description: "Git tag identifying the GitHub release"
      github_token_var:
        type: env_var_name
        default: GITHUB_TOKEN
        description: "Environment variable containing the GitHub token"
    steps:
      - run:
          name: Upload asset to GitHub release
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "No version to release or binary skipped - skipping asset upload"
              exit 0
            fi

            ASSET_PATH="<< parameters.asset_path >>"
            ASSET_NAME="<< parameters.asset_name >>"
            TOKEN="${<< parameters.github_token_var >>}"
            TAG="<< parameters.release_tag >>"

            if [ -z "${ASSET_NAME}" ]; then
              ASSET_NAME="$(basename "${ASSET_PATH}")"
            fi

            if [ ! -f "${ASSET_PATH}" ]; then
              echo "ERROR: Asset file not found: ${ASSET_PATH}" >&2
              exit 1
            fi

            # Derive repo slug from git remote
            REPO_URL=$(git remote get-url origin)
            REPO_SLUG=$(echo "$REPO_URL" | sed -E 's|.*github\.com[:/]||' | sed 's|\.git$||')
            echo "Repository: ${REPO_SLUG}"
            echo "Looking up release for tag ${TAG}..."

            RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://api.github.com/repos/${REPO_SLUG}/releases/tags/${TAG}")

            HTTP_CODE=$(echo "${RELEASE_RESPONSE}" | tail -1)
            RELEASE_BODY=$(echo "${RELEASE_RESPONSE}" | sed '$d')

            if [ "${HTTP_CODE}" != "200" ]; then
              echo "ERROR: GitHub API returned HTTP ${HTTP_CODE}" >&2
              echo "${RELEASE_BODY}" | jq -r '.message // .' >&2
              exit 1
            fi

            RELEASE_ID=$(echo "${RELEASE_BODY}" | jq -r '.id')

            if [ -z "${RELEASE_ID}" ] || [ "${RELEASE_ID}" = "null" ]; then
              echo "ERROR: Could not find GitHub release for tag ${TAG}" >&2
              exit 1
            fi

            echo "Uploading ${ASSET_NAME} to release ${RELEASE_ID}..."
            UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -X POST \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/octet-stream" \
              "https://uploads.github.com/repos/${REPO_SLUG}/releases/${RELEASE_ID}/assets?name=${ASSET_NAME}" \
              --data-binary "@${ASSET_PATH}")

            HTTP_CODE=$(echo "${UPLOAD_RESPONSE}" | tail -1)
            UPLOAD_BODY=$(echo "${UPLOAD_RESPONSE}" | sed '$d')

            if [ "${HTTP_CODE}" != "201" ]; then
              echo "ERROR: Upload failed with HTTP ${HTTP_CODE}" >&2
              echo "${UPLOAD_BODY}" | jq -r '.message // .' >&2
              exit 1
            fi

            echo "Upload complete: ${ASSET_NAME}"

  # Generate an ephemeral minisign signing keypair for cargo-binstall.
  # Exports BINSTALL_SIGNING_PUBKEY to BASH_ENV for the pre-release hook
  # and keeps the private key at /tmp/release-signing/minisign.key for sign_binary.
  generate_signing_key:
    description: >
      Generate an ephemeral minisign keypair for cargo-binstall signature verification.
      Exports BINSTALL_SIGNING_PUBKEY to BASH_ENV for inject_pubkey_and_amend.
      Private key persists at /tmp/release-signing/minisign.key for sign_binary.
      Skipped when SKIP_RELEASE=true: the original key session is gone.
    steps:
      - run:
          name: Generate ephemeral signing key
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"
            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "No version to release or already released - skipping key generation"
              exit 0
            fi

            SIGNING_DIR="/tmp/release-signing"
            mkdir -p "$SIGNING_DIR"

            rsign generate -W -p "$SIGNING_DIR/minisign.pub" -s "$SIGNING_DIR/minisign.key"

            PUBKEY=$(grep -v '^untrusted' "$SIGNING_DIR/minisign.pub" | tr -d '\n')
            echo "Generated ephemeral signing pubkey: $PUBKEY"

            echo "export BINSTALL_SIGNING_PUBKEY=$PUBKEY" >> "$BASH_ENV"

            rm -f "$SIGNING_DIR/minisign.pub"

  # After sign_binary succeeds: write the proven pubkey into Cargo.toml,
  # amend the release commit (made by cargo release --no-push), and move
  # the signed tag to the amended commit. Only then is the pubkey committed.
  inject_pubkey_and_amend:
    description: >
      Inject the confirmed signing pubkey into Cargo.toml, amend the release
      commit produced by cargo release --no-push, and move the signed tag to
      the amended commit. Must run after sign_binary succeeds and before push.
      Skipped when SKIP_RELEASE=true (commit already pushed) or when
      BINSTALL_SIGNING_PUBKEY is unset (non-binary release).
    parameters:
      package:
        type: string
        description: "Package name (used to locate Cargo.toml and derive tag name)"
    steps:
      - run:
          name: Inject pubkey into Cargo.toml and amend release commit
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "Skipping pubkey injection (no version or already released)"
              exit 0
            fi

            if [ -z "$BINSTALL_SIGNING_PUBKEY" ]; then
              echo "No signing pubkey available - skipping Cargo.toml update"
              exit 0
            fi

            TAG="<< parameters.package >>-v${VERSION}"
            CARGO_TOML="crates/<< parameters.package >>/Cargo.toml"

            # Update Cargo.toml with the pubkey confirmed by successful signing
            sed -i "s|pubkey = \".*\"|pubkey = \"$BINSTALL_SIGNING_PUBKEY\"|" "$CARGO_TOML"
            echo "Updated $CARGO_TOML with confirmed signing pubkey"

            # Amend the release commit to include the pubkey
            git add "$CARGO_TOML"
            git commit --amend --no-edit -S

            # Move the signed tag to the amended commit
            git tag -f -s "${TAG}" -m "${TAG}"
            echo "Release commit amended and tag ${TAG} moved to amended commit"

  # Sign a binary archive with the ephemeral minisign key generated by
  # generate_signing_key (at /tmp/release-signing/minisign.key).
  sign_binary:
    description: >
      Sign a binary archive with the ephemeral minisign key generated by
      generate_signing_key (at /tmp/release-signing/minisign.key).
    parameters:
      asset_path:
        type: string
    steps:
      - run:
          name: Sign archive with rsign
          command: |
            set -eo pipefail

            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"

            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "Binary signing skipped"
              exit 0
            fi

            KEY_FILE="/tmp/release-signing/minisign.key"
            if [ ! -f "$KEY_FILE" ]; then
              echo "ERROR: Signing key not found at $KEY_FILE" >&2
              echo "The generate_signing_key command should have created this key" >&2
              exit 1
            fi

            rsign sign -W \
              -s "$KEY_FILE" \
              -x "<< parameters.asset_path >>.sig" \
              "<< parameters.asset_path >>"

            echo "Signature created: << parameters.asset_path >>.sig"

            # Discard key material
            rm -f "$KEY_FILE"

jobs:
  tools:
    executor:
      name: toolkit/rust_env_rolling
    steps:
      - run:
          name: Verify tools
          command: |
            set -ex
            nextsv --version
            pcu --version
            cargo release --version
            jq --version
            rsign --version || echo "rsign2 not pre-installed (will install at runtime)"

  # Pre-approval version calculation job.
  # Runs BEFORE the approval gate so the reviewer knows exactly what will be
  # released. Persists calculated versions to the workspace; release jobs read
  # from there and never recalculate, guaranteeing the approved versions are used.
  calculate-versions:
    executor:
      name: toolkit/rust_env_rolling
    steps:
      - checkout
      - run:
          name: Calculate release versions
          command: |
            set -eo pipefail

            # gen-changelog crate version: use override if provided, else nextsv
            if [ "<< pipeline.parameters.gen_changelog_version >>" != "" ]; then
              GEN_CHANGELOG_VERSION="<< pipeline.parameters.gen_changelog_version >>"
              echo "gen-changelog: using specified version: $GEN_CHANGELOG_VERSION"
            else
              GEN_CHANGELOG_VERSION=$(nextsv -q -bn calculate \
                --package gen-changelog --prefix gen-changelog-v 2>/dev/null || echo "none")
              echo "gen-changelog: calculated version: $GEN_CHANGELOG_VERSION"
            fi

            # Workspace version: v* tags, independent of crate releases.
            # nextsv regex (v\d+\.\d+\.\d+) matches inside crate-prefixed tags like
            # gen-changelog-v0.1.6 because the embedded v0.1.6 satisfies the pattern.
            # Work around by deleting local crate-prefixed tags so nextsv only sees v*.
            git tag -l 'gen-changelog-v*' | xargs -r git tag -d
            WORKSPACE_VERSION=$(nextsv -q -bn calculate --prefix v 2>/dev/null || echo "none")
            echo "workspace: calculated version: $WORKSPACE_VERSION"

            echo ""
            echo "======================================="
            echo "  Versions pending release approval"
            echo "======================================="
            echo "  gen-changelog crate : ${GEN_CHANGELOG_VERSION}"
            echo "  workspace (v*)      : ${WORKSPACE_VERSION}"
            echo "======================================="
            echo ""
            echo "Approve the 'approve-release' job to proceed with the above versions."

            # Persist to workspace so downstream jobs use exactly these versions
            mkdir -p /tmp/release-versions
            {
              echo "GEN_CHANGELOG_VERSION=${GEN_CHANGELOG_VERSION}"
              echo "WORKSPACE_VERSION=${WORKSPACE_VERSION}"
            } > /tmp/release-versions/versions.env
            cat /tmp/release-versions/versions.env
      - persist_to_workspace:
          root: /tmp/release-versions
          paths:
            - versions.env

  # Release job: reads pre-calculated version from workspace (set by
  # calculate-versions before the approval gate) then runs cargo release,
  # optionally builds/signs/uploads binary.
  release-crate:
    parameters:
      package:
        type: string
      build_binary:
        type: boolean
        default: false
        description: "Whether to build and upload a release binary"
      binary_name:
        type: string
        default: ""
        description: "Name of the binary in target/release"
      target:
        type: string
        default: x86_64-unknown-linux-gnu
        description: "Rust target triple for the archive name"
    executor:
      name: toolkit/rust_env_rolling
    steps:
      - checkout
      # Load the version approved before the gate — never recalculate
      - attach_workspace:
          at: /tmp/release-versions
      - run:
          name: Load approved version for << parameters.package >>
          command: |
            set -eo pipefail
            source /tmp/release-versions/versions.env

            # Select the version for this specific package
            case "<< parameters.package >>" in
              gen-changelog)
                VERSION="$GEN_CHANGELOG_VERSION"
                ;;
              *)
                echo "Unknown package: << parameters.package >>" >&2
                exit 1
                ;;
            esac

            echo "Approved version for << parameters.package >>: $VERSION"
            echo "export NEXT_VERSION=$VERSION" >> "$BASH_ENV"
            echo "export SEMVER=$VERSION" >> "$BASH_ENV"
      - toolkit/gpg_key
      - toolkit/git_config
      # Update pcu to latest (needed for make_github_release and push with GitHub App authority)
      - run:
          name: Update to latest pcu
          command: |
            cargo install --force --git https://github.com/jerus-org/pcu --branch main
      # Install rsign2 for binary signing (prototype: migrate to ci-container later)
      - when:
          condition: << parameters.build_binary >>
          steps:
            - run:
                name: Install rsign2
                command: cd /tmp && cargo install rsign2
      # Step 1: Check crates.io for recovery scenarios
      - check_crates_io_version:
          package: << parameters.package >>
      # Step 2: Check if tag already exists for recovery scenarios
      - check_tag_exists:
          package: << parameters.package >>
      # Step 4: cargo release WITHOUT publish or push.
      # The pre-release hook rebuilds README and generates CHANGELOG.
      # Cargo.toml pubkey is NOT updated here — that happens after signing succeeds.
      - make_cargo_release:
          package: << parameters.package >>
          verbosity: "-vv"
          publish: false
          no_push: true
      # Steps 5-8: Build binary, generate key, sign, then inject pubkey.
      # All skipped when SKIP_RELEASE=true (tag already on remote, key session gone).
      # Order is deliberate: pubkey only enters Cargo.toml after signing proves the key
      # works, then the release commit is amended and the tag moved — before any push.
      - when:
          condition: << parameters.build_binary >>
          steps:
            - build_release_binary
            - package_binary:
                binary_name: << parameters.binary_name >>
                target: << parameters.target >>
            - generate_signing_key
            - sign_binary:
                asset_path: << parameters.binary_name >>-<< parameters.target >>.tar.gz
            - inject_pubkey_and_amend:
                package: << parameters.package >>
      # Step 9: Push the amended release commit and tag via pcu (GitHub App authority).
      # pcu push uses the GitHub App installation token, which has branch protection
      # bypass authority. Skipped when SKIP_RELEASE=true (already on remote).
      - run:
          name: Push release commit and tag
          command: |
            set -eo pipefail
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"
            if [ "$VERSION" = "none" ] || [ "$SKIP_RELEASE" = "true" ]; then
              echo "Skipping push (no version or tag already on remote)"
              exit 0
            fi
            echo "Pushing main and << parameters.package >>-v${VERSION} via pcu..."
            pcu push --semver "${VERSION}" --prefix "<< parameters.package >>-v"
      # Step 10: Create GitHub release (idempotent — checks for existing release first)
      - make_github_release:
          package: << parameters.package >>
          verbosity: "-vv"
      # Step 12: Upload binary and signature.
      # Skipped when SKIP_RELEASE=true (key session gone, binary can't be signed).
      - when:
          condition: << parameters.build_binary >>
          steps:
            - upload_release_asset:
                asset_path: << parameters.binary_name >>-<< parameters.target >>.tar.gz
                release_tag: << parameters.package >>-v${VERSION}
            - upload_release_asset:
                asset_path: << parameters.binary_name >>-<< parameters.target >>.tar.gz.sig
                release_tag: << parameters.package >>-v${VERSION}
      # Step 13: Publish to crates.io LAST.
      # The pubkey in the published Cargo.toml always matches the signed binary above
      # because we only reach this step after signing and pushing succeed.
      # SKIP_PUBLISH=true means crates.io already has this version — skip.
      - run:
          name: Publish to crates.io
          command: |
            set -eo pipefail
            VERSION="${SEMVER:-${NEXT_VERSION:-none}}"
            if [ "$VERSION" = "none" ] || [ "$SKIP_PUBLISH" = "true" ]; then
              echo "Skipping publish (no version or already published)"
              exit 0
            fi
            cargo publish --package << parameters.package >>

  # Workspace release job: reads the pre-calculated v* version from the workspace
  # (set by calculate-versions before the approval gate), then creates the GitHub
  # release and updates PRLOG.md.
  # Runs after all crate releases because a crate release only tags with the
  # crate-prefixed tag (gen-changelog-v*); the workspace (v*) release is separate.
  release-prlog:
    executor:
      name: toolkit/rust_env_rolling
    steps:
      - checkout
      # Load the version approved before the gate — never recalculate
      - attach_workspace:
          at: /tmp/release-versions
      - run:
          name: Load approved workspace version
          command: |
            set -eo pipefail
            source /tmp/release-versions/versions.env
            echo "Approved workspace version: $WORKSPACE_VERSION"
            echo "export NEXT_VERSION=$WORKSPACE_VERSION" >> "$BASH_ENV"
            echo "export SEMVER=$WORKSPACE_VERSION" >> "$BASH_ENV"
      - toolkit/gpg_key
      - toolkit/git_config
      - run:
          name: Pull latest main
          command: git pull --rebase origin main
      # Update pcu to latest (workspace release command not yet in toolkit release)
      - run:
          name: Update to latest pcu
          command: |
            cargo install --force --git https://github.com/jerus-org/pcu --branch main
      # Create workspace GitHub release and update PRLOG.md with release date
      - make_github_release:
          prefix: "v"
          verbosity: "-vv"
          update_prlog: true

workflows:
  release:
    jobs:
      - tools

      # Calculate versions BEFORE the approval gate so the reviewer knows
      # exactly what will be released. The approved versions are persisted to
      # the workspace and used unchanged by the release jobs after approval.
      - calculate-versions:
          requires: [tools]
          context:
            - release

      - approve-release:
          type: approval
          requires: [calculate-versions]

      - release-crate:
          name: release-gen-changelog
          requires: [approve-release]
          package: gen-changelog
          build_binary: true
          binary_name: gen-changelog
          context:
            - release
            - bot-check
            - pcu-app

      # Release workspace (v* tag) and update PRLOG after crate release.
      # Crate release only creates gen-changelog-v* tags; workspace release
      # is independent and tracks all changes via v* tags.
      - release-prlog:
          requires: [release-gen-changelog]
          context:
            - release
            - bot-check
            - pcu-app
